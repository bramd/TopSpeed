# WASM Infrastructure Design

## Overview

Port TopSpeed 3 to WebAssembly (WASM) for browser-based play. Goal is a playable demo initially, with full port as the target.

## Toolchain

- **Emscripten SDK 4.0.21** installed at `F:/emsdk`
- **SDL2** via Emscripten's built-in port (`-s USE_SDL=2`)
- **ASYNCIFY** for synchronous-to-async file loading bridging

## Build System

Add Emscripten presets to `CMakePresets.json`:
- `emscripten-debug` - Debug WASM build
- `emscripten-release` - Release WASM build (optimized)

Key compiler/linker flags:
- `-s USE_SDL=2` - Emscripten's SDL2 port
- `-s ASYNCIFY` - Enable async/sync bridging for file loads
- `-s ALLOW_MEMORY_GROWTH` - Dynamic memory for audio buffers

Output files:
- `topspeed.html` - Generated HTML shell
- `topspeed.js` - JS glue code
- `topspeed.wasm` - Compiled game

## Asset Loading Strategy

### Three-tier loading approach:

**Tier 1 - Preload (before main):**
- `Sounds/*.wav` - UI sounds, logo
- `Sounds/En/menu/*.ogg` - Core menu prompts
- `Sounds/En/numbers/*.ogg` - Number prompts

**Tier 2 - Background load during logo playback:**
- `Sounds/En/tracks/*.ogg` - Track names
- `Sounds/En/cars/*.ogg` - Car names

**Tier 3 - Lazy load on demand:**
- Track-specific sounds (ambient, surfaces)
- Engine sounds
- Race announcements

### How lazy loading works:
1. Game calls file load function (SDL_LoadWAV, loadOggFile, etc.)
2. Emscripten intercepts the file access
3. ASYNCIFY pauses WASM execution, fetches file via HTTP
4. File is cached in virtual filesystem
5. Execution resumes, game continues

## Web Deployment Structure

```
web/
  index.html      <- Generated by Emscripten
  topspeed.js     <- Generated JS glue code
  topspeed.wasm   <- Compiled game
  Sounds/         <- Served separately, fetched on demand
    En/
      menu/
      numbers/
      tracks/
    effects/
    ...
```

## Platform Differences

| Area | Windows | WASM |
|------|---------|------|
| Main loop | `while(running)` | `emscripten_set_main_loop()` |
| File paths | Backslash OK | Forward slash only |
| Audio init | SDL2 native | SDL2 Emscripten port |
| Threading | `std::thread`, `std::mutex` | Single-threaded (stub mutex) |

### Main loop change:
```cpp
#ifdef __EMSCRIPTEN__
    emscripten_set_main_loop(mainLoopIteration, 0, 1);
#else
    while (running) { mainLoopIteration(); }
#endif
```

### Threading:
Stub out mutex in WASM - browser runs audio callback on main thread via Web Audio API, so no contention.

```cpp
#ifdef __EMSCRIPTEN__
    // No-op - single threaded in WASM
#else
    std::lock_guard<std::mutex> lock(m_mutex);
#endif
```

## Implementation Phases

### Phase 1: Build Infrastructure
- Add Emscripten CMake preset
- Get minimal compilation to WASM working
- Verify emsdk toolchain integration

### Phase 2: Core Game Compilation
- Compile Common, DxCommon, TopSpeed libraries
- Fix platform-specific compile errors
- Stub unsupported features (force feedback, multiplayer)

### Phase 3: Main Loop & Audio
- Implement `emscripten_set_main_loop` wrapper
- Verify SDL2 audio works in browser
- Test basic sound playback

### Phase 4: Asset Loading
- Configure preloaded assets (Tier 1)
- Implement background loading during logo (Tier 2)
- Test lazy loading with ASYNCIFY (Tier 3)

### Phase 5: Polish
- Test full menu navigation
- Test complete race gameplay
- Optimize load times if needed

## Testing

Use `emrun` (included with emsdk) for local testing - handles WASM MIME types correctly and auto-launches browser.

## Features NOT in Scope (Initially)

- Multiplayer (already disabled in SDL2 build)
- Force feedback (no browser API)
- Settings persistence (could add localStorage later)
